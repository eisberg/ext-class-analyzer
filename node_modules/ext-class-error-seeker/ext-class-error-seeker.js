/**
 * This class seeks for errors in ext-classes. Additionally failures from jsHint will be detected
 * To use this class you need an array like the following:
 * {contents: [
 *      "This is the string which contains the content of one file"
 *  ],
 *  classes:
 *  "AnyClassname": {
 *      "path": "/the/absolute/path/to/this/class/if/you/want/it/as/tooltip",
 *      "declarations": {},
 *      "inits": {}
 *  },
 *  "alias":{
 *      "aliasName": "realClassName"
 *  },
 *  "xtype":{
 *      "xTypeName": "realClassName"
 *  },
 *  "anyOtherType":{
 *      "otherTypeName": "realClassName"
 *  }
 *}
 */

"use strict";
var JSHint = require('jshint').JSHINT,


    jsGlobalVariables = GLOBAL,

    classValidator = {
        classDependencies: {},
        errorFiles : {},
        showInfo: true,
        classes: {},
        globalVariables : {},
        classNames: [],
        aliasNames: [],
        xtypeNames: [],
        jsHintOptions : {},
        /**
         * the classDemendencies.contents array will be gone through and searched for errors
         * there is an error-search using jsHint and errors in Ext specific code will be found
         * if showInfo is set to true errors of type inforamtion will be shown otherwise not
         *
         * options should include:
         * {"saveErrorsPath": "", "jsHintOptions" : {}, "globalVariables" : {}, "showInfo": boolean}
         *
         * @param {Object} classDependenciesArray
         * @param {Object} options
         * @returns {Object}
         */
        begin: function (classDependenciesArray, options) {
            this.globalVariables = options.globalVariables;
            this.jsHintOptions = options.jsHintOptions;
            for(var file in classDependenciesArray.contents) {
                if(classDependenciesArray.contents.hasOwnProperty(file)) {
                    JSHint(classDependenciesArray.contents[file].code.toString('utf8'), this.jsHintOptions, this.globalVariables);
                    for (var no = 0; no < JSHint.errors.length; no++) {
                        var error = JSHint.errors[no];
                        if (error !== null) {
                            var type = error.code.charAt(0);
                            if (type !== 'I' || options.showInfo) {
                                if (!this.errorFiles.hasOwnProperty(this.path)) {
                                    this.errorFiles[file] = {};
                                }

                                this.errorFiles[file][error.line + ':' + error.character] = {
                                    reason: error.reason,
                                    type: type
                                };
                            }
                        }
                    }
                }
            }
            this.showInfo = options.showInfo;
            this.classDependencies = classDependenciesArray;
            this.classNames = Object.keys(this.classDependencies.classes);
            this.compareClasses();
            return this.sortErrors();
        },
        /**
         * add an error to errors array but skip errors of type information if showInfo is set to false
         *
         * @param message {String} description for this error
         * @param file {String} path to the actual file
         * @param line {int}
         * @param col {int} start column of the error
         * @param errorType {String} E=Error, W=Warning, I=Information
         */
        addError: function (message, file, line, col, errorType) {
            if(this.showInfo || errorType !== "I") {
                if (!this.errorFiles.hasOwnProperty(file)) {
                    this.errorFiles[file] = {};
                }
                this.errorFiles[file][line + ':' + col] = {
                    reason: message,
                    type: errorType
                };
            }
        },
        /**
         * this type of error will be shown if a class is instantiated within a function but not mentioned in "use" or "require" part
         *
         * @param fileClassName {String} the class where the error occurs
         * @param typeClassName {String} the class which is not mentioned in use or require part
         * @param file {String} path to the file
         * @param line {int}
         * @param col {int}
         */
        addUseRequireError: function (fileClassName, typeClassName, file, line, col) {
            var classObject = typeClassName.split('.')[0];
            if ((!this.globalVariables.hasOwnProperty(classObject) || this.globalVariables[classObject] === true) && !jsGlobalVariables.hasOwnProperty(classObject)) {
                var message = "Class '" + typeClassName + "' is neither listed in use nor in require of class '" + fileClassName + "'";
                this.addError(message, file, line, col, 'E');
            }
        },
        /**
         * this type of warning will be shown if a class is not initialised within the parsed code
         * (if you are sure that this class should be initialised please check if the file where the class should be got parsed)
         *
         * @param fileClassName {String} the class where the error occurs
         * @param typeClassName {String} the class which is not mentioned in use or require part
         * @param file {String} path to the file
         * @param line {int}
         * @param col {int}
         * @param type {String}
         */
        addUnintiializedClassWarning: function (fileClassName, typeClassName, file, line, col, type) {
            var classObject = typeClassName.split('.')[0];
            if ((!this.globalVariables.hasOwnProperty(classObject) || this.globalVariables[classObject] === true) && !jsGlobalVariables.hasOwnProperty(classObject)) {
                var classType = type || 'class',
                    message = "Use of undefined " + classType + " '" + typeClassName + "'";
                this.addError(message, file, line, col, 'W');
            }
        },
        /**
         * This Information will be shown if a class is generated dynamical
         * it is not possible to check whether the class exists or not
         *
         * @param fileClassName {String} the class where the error occurs
         * @param typeClassName {String} the class which is not mentioned in use or require part
         * @param file {String} path to the file
         * @param line {int}
         * @param col {int}
         */
        addSolvingWarning: function (fileClassName, typeClassName, file, line, col) {
            if (typeClassName === '***') {
                typeClassName = '';
            } else {
                typeClassName = " '" + typeClassName + "'";
            }
            var message = "Dynamic class name" + typeClassName + ". Could not resolve it. Please check";
            this.addError(message, file, line, col, 'I');
        },
        addUnnecessaryClassWarning: function (fileClassName, typeClassName, file, line, col) {
            var message = "Unnecessary Class '" + typeClassName + "'";
            this.addError(message, file, line, col, 'I');
        },
        /**
         * look if the name for any type exists as a class or it is dynamic
         * will show a warning if the typename does not exist and if it is dynamicly created
         * it will show an information
         *
         * actually implemented are: xtype, ftype and ptype
         * to look for other types they have to be in classes.inits array and in classes[type] array
         *
         * @param allTypesOfThis {Array}
         * @param typeName {String}
         * @param pathClassName {String}
         * @param path {String}
         * @returns {Object}
         */
        variousTypeHandler: function (allTypesOfThis, typeName, pathClassName, path) {
            var usedClasses = {};
            for (var m = 0; m < allTypesOfThis.length; m++) {
                var oneType = allTypesOfThis[m],
                    name = oneType.name,
                    line = oneType.line,
                    col = oneType.col_start;
                if (oneType.dynamic == true) {
                    this.addSolvingWarning(pathClassName, name, path, line, col);
                } else {
                    if (!this.classDependencies[typeName].hasOwnProperty(name)) {
                        this.addUnintiializedClassWarning(pathClassName, name, path, line, col, typeName);
                    } else {
                        usedClasses[this.classDependencies[typeName][name]] = {
                            "line": line,
                            "col": col
                        };
                    }
                }
            }
            return usedClasses;
        },
        /**
         * sorts the errors. they will be sorted by pathname and then by line and column inside a file
         *
         * @returns {Object}
         */
        sortErrors: function(){
            var errorfiles = Object.keys(this.errorFiles),
                sortedErorrs = {};
            errorfiles.sort();
            for(var key = 0; key < errorfiles.length; key++){
                var fileErrors = Object.keys(this.errorFiles[errorfiles[key]]);
                fileErrors.sort(function(a,b){
                    var aSep = a.split(":");
                    var bSep = b.split(":");
                    if(aSep[0] === bSep[0]){
                        return aSep[1] - bSep[1];
                    } else {
                        return aSep[0] - bSep[0]
                    }
                });
                for(var oneError = 0; oneError<fileErrors.length; oneError++){
                    if(!sortedErorrs.hasOwnProperty(errorfiles[key])){
                        sortedErorrs[errorfiles[key]] = {};
                    }
                    sortedErorrs[errorfiles[key]][fileErrors[oneError]] = this.errorFiles[errorfiles[key]][fileErrors[oneError]];
                }
            }
            return sortedErorrs;
        },
        /**
         * goes through every class and looks for errors which are ext-specific
         */
        compareClasses: function () {
            for (var className in this.classDependencies.classes) {
                if (this.classDependencies.classes.hasOwnProperty(className)) {
                    var path = this.classDependencies.classes[className].path,
                        current = this.classDependencies.classes[className],
                        declarationNames = {},
                        initClasses = [];
                    for (var type in current.declarations) {
                        if (current.declarations.hasOwnProperty(type)) {
                            var i = 0;
                            switch (type) {
                                case ('requires'):
                                    for (i; i < current.declarations.requires.length; i++) {
                                        var currentRequire = current.declarations.requires[i];
                                        declarationNames[currentRequire.name] = {
                                            "line": currentRequire.line,
                                            "col": currentRequire.col_start,
                                            "used": false
                                        };
                                    }
                                    break;
                                case ('uses'):
                                    for (i; i < current.declarations.uses.length; i++) {
                                        var currentUse = current.declarations.uses[i];
                                        declarationNames[currentUse.name] = {
                                            "line": currentUse.line,
                                            "col": currentUse.col_start,
                                            "used": false
                                        };
                                    }
                                    break;
                            }
                        }
                    }
                    for (var initType in current.inits) {
                        if (current.inits.hasOwnProperty(initType)) {
                            var name,
                                line,
                                col;
                            switch (initType) {
                                case ('creates'):
                                    var creates = current.inits['creates'];
                                    for (var k = 0; k < creates.length; k++) {
                                        var create = creates[k];
                                        name = create.name;
                                        line = create.line;
                                        col = create.col_start;
                                        if (create.dynamic == true) {
                                            this.addSolvingWarning(className, name, path, line, col);
                                        } else {
                                            if (!(declarationNames.hasOwnProperty(name))) {
                                                this.addUseRequireError(className, name, path, line, col);
                                            } else {
                                                declarationNames[name].used = true;
                                                if (!(this.classNames.indexOf(name) >= 0)) {
                                                    this.addUnintiializedClassWarning(className, create.name, path, line, col);
                                                } else {
                                                    initClasses.push(name)
                                                }
                                            }
                                        }
                                    }
                                    break;
                                case ('ObjectInit'):
                                    var news = current.inits['ObjectInit'];
                                    for (var l = 0; l < current.inits['ObjectInit'].length; l++) {
                                        var currentNew = news[l];
                                        name = currentNew.name;
                                        line = currentNew.line;
                                        col = currentNew.col_start;
                                        if (currentNew.dynamic == true) {
                                            this.addSolvingWarning(className, name, path, line, col);
                                        } else {
                                            if (!(declarationNames.hasOwnProperty(name))) {
                                                this.addUseRequireError(className, name, path, line, col);
                                            } else {
                                                declarationNames[name].used = true;
                                                if (!(this.classNames.indexOf(name) >= 0)) {
                                                    this.addUnintiializedClassWarning(className, name, path, line, col);
                                                } else {
                                                    initClasses.push(name);
                                                }
                                            }
                                        }
                                    }
                                    break;
                                case ('xtype'):
                                case ('ptype'):
                                case ('ftype'):
                                    var allTypes = current.inits[initType],
                                        usedClasses = this.variousTypeHandler(allTypes, initType, className, path);
                                    for (var usedClass in usedClasses) {
                                        if (usedClasses.hasOwnProperty(usedClass)){
                                            if (declarationNames.hasOwnProperty(usedClass)) {
                                                declarationNames[usedClass].used = true;
                                            } else {
                                                line = usedClasses[usedClass].line;
                                                col = usedClasses[usedClass].col;
                                                this.addUseRequireError(className, usedClass, path, line, col);
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                    }

                    for (var decName in declarationNames) {
                        if (declarationNames.hasOwnProperty(decName)) {
                            if (declarationNames[decName].used === false) {
                                this.addUnnecessaryClassWarning(className, decName, path, declarationNames[decName].line, declarationNames[decName].col);
                            }
                        }
                    }
                }
            }
        }
    };

module.exports = {
    /**
     * the classDemendencies.contents array will be gone through and searched for errors
     * there is an error-search using jsHint and errors in Ext specific code will be found
     * if showInfo is set to true errors of type inforamtion will be shown otherwise not
     *
     * options should include:
     * {"saveErrorsPath": "", "jsHintOptions" : {}, "globalVariables" : {}, "showInfo": boolean}
     *
     * @param classDependenciesArray {Object}
     * @param options {Object}
     * @returns {Object}
     */
    begin: function(classDependenciesArray, options){
        return classValidator.begin(classDependenciesArray, options);
    }
};