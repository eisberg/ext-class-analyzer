"use strict";


var path = require('path'),
    fs = require('fs'),
    esprima = require('esprima'),
    sloc = require('sloc');

/**
 * consists contents of all files which should be parser for errors and all other
 * class information for all parsed classes
 *
 * @type {Object}
 */
var classDependencies = {
    contents: {},
    classes: {},
    alias: {},
    xtype: {},
    ptype: {},
    ftype: {}
};
/**
 * this Object takes one class and seeks for dependency information
 */
var classSeeker = {
    className: '',
    path: '',
    foundClasses: {},
    foundDeclarations: {},
    foundInits: {},
    parsedDefinePart: [],
    definitions: [],
    functions: [],
    content : '',

    skipPaths: [ ],

    addClass: function (name, classesArray) {
        classDependencies.classes[name] = classesArray;
    },
    addAlias: function (alias, className){
        classDependencies.alias[alias] = className;
    },
    addXtype: function (xtype, className){
        classDependencies.xtype[xtype] = className;
    },
    addFtype: function (ftype, className){
        classDependencies.ftype[ftype] = className;
    },
    addPtype: function (ptype, className){
        classDependencies.ptype[ptype] = className;
    },
    /**
     * Determines if the current file has to needs to have a minimal run
     *
     * @param fileName {String}
     * @returns {boolean}
     */
    ignorePath: function (fileName){
        for(var k = 0; k < this.skipPaths.length; k++) {
            if (fileName.replace(new RegExp(path.sep.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"),'g'),'/').match(this.skipPaths[k])) {
                return true;
            }
        }
        return false;
    },
    /**
     * Scans for every "Ext.define" and makes the dependency Array otherwise the file will be excluded/skipped
     * if the whole file has no "Ext.define"
     *
     * @param parsedFileBody {Object} file scanned by esprima (just the body)
     * @param pathOfFile {String}
     * @param content {String}
     * @param skipPaths {Array}
     */
    lookUp : function (parsedFileBody, pathOfFile, content, skipPaths){
        var extDefines = this.tokenRunner.searchInJson(parsedFileBody, 'name', 'define'),
            excluded = 0;
        this.path = pathOfFile;
        this.content = content;
        this.skipPaths = skipPaths;
        var ignorePathBool = this.ignorePath(pathOfFile);
        for(var i = 0; i < extDefines.length; i++){
            if(this.extCheck(extDefines[i])){
                this.scan(extDefines[i], ignorePathBool);
            } else {
                excluded++;
            }
        }
        if(excluded == extDefines.length){
            console.log('Excluded: ' + pathOfFile)
        } else {
            if(!ignorePathBool) {
                var stats = sloc(content,"js");
                classDependencies.contents[this.path] = {"code": content, "loc":stats};
            }
        }
    },
    /**
     * seeks for every interesting information in the result of a Ext.define part in esprima and makes a fast run
     * if the path of file matches to the ignorePath
     *
     * the fast run will not run jsHint on the file and just look for definitions in a class
     *
     * @param parsedContentDefine {Object}
     * @param ignorePath {boolean}
     */
    scan: function (parsedContentDefine, ignorePath) {
        this.foundClasses = {};
        this.definitions = [];
        this.functions = [];
        this.foundDeclarations = {};
        this.foundInits = {};
        this.parsedDefinePart = parsedContentDefine;
        this.className = this.parsedDefinePart['arguments'][0].value;
        this.separateDeclarationsFromFunctions();
        this.getDeclarations(ignorePath);
        if(!ignorePath) {
            this.getFunctions();
            this.getInits();
        } else {
            classDependencies.inits = {};
        }
        this.addClass(this.className, this.foundClasses);
    },
    /**
     * Check if Ext.define exists and can be regarded
     *
     * @param parsedContent {Object}
     * @returns {boolean}
     */
    extCheck: function (parsedContent) {
        //console.log(this.path);
        //console.log(JSON.stringify(this.parsedDefinePart,null,2));
        if(parsedContent) {
            if (parsedContent.type === 'CallExpression') {
                if (parsedContent.callee.type === 'MemberExpression') {
                    if (parsedContent.callee.object.name === 'Ext' &&
                        parsedContent.callee.property.name === 'define') {
                        if(parsedContent['arguments'][0].type === 'Literal') {
                            if(parsedContent['arguments'][0].value !== null) {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false
    },
    /**
     * seeks for every definition in a class. If fast run skips "requires" and "uses"
     *
     * @param ignorePath {boolean}
     */
    getDeclarations : function (ignorePath) {
        this.findAlias();
        this.findXtypeDec();
        this.findExtends();
        this.findMixins();
        if(!ignorePath) {
            this.findRequire();
            this.findUse();
        }
        this.foundClasses['path'] = this.path;
        this.foundClasses['declarations'] = this.foundDeclarations;
    },
    getFunctions : function (){
        var functions = [];
        this.functions.forEach(function(func){
            var name = func.key.name,
                paramCount = func.value.params.length,
                startLine = func.key.loc.start.line,
                startCol = func.key.loc.start.column;
            functions.push({
                "name" : name,
                "params": paramCount,
                "line": startLine,
                "start_col": startCol
            });
        });
        this.foundClasses['functions'] = functions;
    },
    /**
     * seeks for every instantiations in a class
     */
    getInits : function () {
        this.findCreate();
        this.findVarousTypeInit('xtype');
        this.findVarousTypeInit('ftype');
        this.findVarousTypeInit('ptype');
        this.findNew();
        this.foundClasses['inits'] = this.foundInits;
    },
    /**
     * separates all definitions from functions in a part of the esprima json of an ext.define part
     */
    separateDeclarationsFromFunctions: function (){
        var properties;
        switch (this.parsedDefinePart['arguments'][1].type){
            case "ObjectExpression":
                properties = this.parsedDefinePart['arguments'][1].properties;
                break;
            case "CallExpression":
            case "FunctionExpression":
                properties = [];
                break;
        }
        for(var i = 0; i < properties.length; i++){
            if(properties[i].value.type != 'FunctionExpression'){
                if(['alias', 'xtype', 'uses', 'extend', 'requires', 'mixins'].indexOf(properties[i].key.name) >= 0) {
                    this.definitions.push(properties[i]);
                }
            } else {
                this.functions.push(properties[i]);
            }
        }
    },
    /**
     * detects a key word at the beginning of an alias and puts it in the right type-array
     *
     * following keywords are implemented: widget, feature, plugin
     *
     * @param value {String} from alias
     */
    findVarousTypeInAlias: function (value){
        var
            keyword = value.split('.')[0],
            name = value.substr(keyword.length + 1);
        switch (keyword){
            case 'widget':
                this.addXtype(name, this.className);
                break;
            case 'feature':
                this.addFtype(name, this.className);
                break;
            case 'plugin':
                this.addPtype(name, this.className);
                break;
        }
    },
    /**
     * detects keyword "alias" and adds the value to the alias and, if implemented, in the right type of the class
     */
    findAlias: function () {
        var alias = this.tokenRunner.searchInJson(this.definitions, 'name', 'alias');
        if(alias.length == 1) {
            var alName = '';
            if(alias[0].value.type == 'ArrayExpression'){
                for(var i = 0; i < alias[0].value.elements.length; i++){
                    alName = alias[0].value.elements[i].value;
                    this.findVarousTypeInAlias(alName);
                    this.addAlias(alName,this.className);
                }
            } else {
                alName = alias[0].value.value;
                this.findVarousTypeInAlias(alName);
            }
            this.addAlias(alName, this.className);
        }
    },
    /**
     * detects keyword "mixins" and adds values to class
     */
    findMixins: function() {
        var mixin = this.tokenRunner.searchInJson(this.definitions, 'name', 'mixins'),
            mixins = [],
            i = 0;
        if(mixin.length == 1){
            switch (mixin[0].value.type){
                case("ObjectExpression"):
                    for(i; i < mixin[0].value.properties.length;i++){
                        mixins.push({
                            name: mixin[0].value.properties[i].value.value,
                            line: mixin[0].value.properties[i].value.loc.start.line,
                            col_start: mixin[0].value.properties[i].value.loc.start.column
                        });
                    }
                    break;
                case("ArrayExpression"):
                    for(i; i < mixin[0].value.elements.length;i++){
                        mixins.push({
                            name: mixin[0].value.elements[i].value,
                            line: mixin[0].value.elements[i].loc.start.line,
                            col_start: mixin[0].value.elements[i].loc.start.column
                        });
                    }
                    break;
            }
            this.foundDeclarations.mixins = mixins;
        }
    },
    /**
     * if "xtype"-definition exists for class it will be detected and added to class
     */
    findXtypeDec: function () {
        var xtype = this.tokenRunner.searchInJson(this.definitions, 'name', 'xtype');
        if(xtype.length == 1) {
            var xName = '';
            if(xtype[0].value.type == 'ArrayExpression'){
                for(var i = 0; i < xtype[0].value.elements.length; i++){
                    xName = xtype[0].value.elements[i].value;
                    this.addXtype(xName, this.className);
                }
            } else {
                xName = xtype[0].value.value;
                this.addXtype(xName, this.className);
            }
        }
    },
    /**
     * if "extend" exists for class it will be detected and added to class
     */
    findExtends: function () {
        var extend = this.tokenRunner.searchInJson(this.definitions, 'name', 'extend');
        if (extend.length == 1) {
            var exLine = extend[0].value.loc.start.line,
                exName = extend[0].value.value,
                exCol = extend[0].value.loc.start.column;
            this.foundDeclarations['extend'] = {
                name: exName,
                line: exLine,
                col_start: exCol
            };
        }
    },
    /**
     * if "requires" exist for class it will be detected and added to class
     */
    findRequire: function () {
        var elements = this.normalSearch(this.definitions, 'requires');
        if (elements.length != 0) {
            this.foundDeclarations['requires'] = elements;
        }
    },
    /**
     *  if "uses" exist for class it will be detected and added to class
     */
    findUse: function () {
        var elements = this.normalSearch(this.definitions, 'uses');
        if (elements.length !== 0) {
            this.foundDeclarations['uses'] = elements;
        }
    },
    /**
     * looks for the given type in functions and puts the value to class
     *
     * if the value is generated dynamically the dynamic flag will be set to true
     *
     * @param specialType {String} i.e. 'xtype', 'ftype', 'ptype'
     */
    findVarousTypeInit: function (specialType) {
        var typeInits = this.tokenRunner.searchInJson(this.functions, 'name', specialType),
            classes = [];
        for (var i = 0; i < typeInits.length; i++) {
            if (typeInits[i].type == 'Property') {
                var line = typeInits[i].value.loc.start.line,
                    col = typeInits[i].value.loc.start.column,
                    dynamic = true,
                    name = '';
                switch (typeInits[i].value.type) {
                    case ('CallExpression'):
                        if(typeInits[i].value.callee.object.type == 'ThisExpression'){
                            name = 'this';
                        } else{
                            name = typeInits[i].value.callee.object.name;
                        }
                        name = name + '.' + typeInits[i].value.callee.property.name;
                        break;
                    case ('MemberExpression'):
                        if(typeInits[i].value.object.type === 'ThisExpression'){
                            name = 'this'
                        } else {
                            name = typeInits[i].value.object.name;
                        }
                        name = name + '.' + typeInits[i].value.property.name;
                        break;
                    case ('Identifier'):
                        name = '***';
                        break;
                    case ('BinaryExpression'):
                        name = '***';
                        break;
                    default :
                        if(typeInits[i].value.type === 'ConditionalExpression'){
                            name = '***';
                        } else {
                            name = typeInits[i].value.value;
                            dynamic = false;
                        }
                        break;
                }
                classes.push({
                    name: name,
                    line: line,
                    col_start: col,
                    dynamic: dynamic
                });
                if (classes.length != 0) {
                    this.foundInits[specialType] = classes;
                }
            }
        }
    },
    /**
     * detects if a new class is generated by "new" keyword
     *
     * if the classname is generated dynamically the dynamic flag will be set to true
     */
    findNew: function () {
        var foundObjects = [],
            found = this.tokenRunner.searchInJson(this.functions, 'type', 'NewExpression');
        for (var k = 0; k < found.length; k++) {
            var foundObject = found[k],
                line = foundObject.loc.start.line,
                col = foundObject.loc.start.column,
                dynamic = false;
            foundObject = this.tokenRunner.searchInJson(foundObject.callee, 'type', 'Identifier');
            var calls = foundObject.length,
                className = '';
            for (var l = 0; l < calls; l++) {
                if(foundObject.hasOwnProperty(l)) {
                    if (l == 0) {
                        if (col + 4 != foundObject[l].loc.start.column) {
                            className += 'this.';
                            dynamic = true;
                        }
                    }
                    className += foundObject[l].name;
                    if (l != calls - 1) {
                        className += '.';
                    }
                }
            }
            foundObjects.push({
                name: className,
                line: line,
                col_start: col,
                dynamic: dynamic
            });
        }
        if (foundObjects.length != 0) {
            this.foundInits['ObjectInit'] = foundObjects;
        }
    },
    /**
     * can be used if the value for a key is an array
     *
     * @param json {Object} state if you want to examine the definitions or the functions
     * @param value {String}
     * @returns {Array}
     */
    normalSearch: function (json , value) {
        var found = this.tokenRunner.searchInJson(json, 'name', value);
        if (found.length != 0) {
            found = found[0].value.elements;
            var elements = [];
            for (var i = 0; i < found.length; i++) {
                elements.push({
                    name: found[i].value,
                    line: found[i].loc.start.line,
                    col_start: found[i].loc.start.column
                });
            }
            return elements;
        } else {
            return [];
        }
    },
    /**
     * will find every "Ext.create" and adds it to the class
     *
     * if the classname is generated dynamically the dynamic flag will be set to true
     */
    findCreate: function () {
        var found = this.tokenRunner.searchInJson(this.functions, 'name', 'create'),
            foundClass = [];
        for (var i = 0; i < found.length; i++) {
            if(found.hasOwnProperty(i)) {
                if (found[i].type == 'CallExpression' &&
                    found[i].callee.object.name == 'Ext' &&
                    found[i].callee.property.name == 'create') {
                    var internClass = '',
                        line = found[i]['arguments'][0].loc.start.line,
                        col = found[i]['arguments'][0].loc.start.column,
                        dynamic = false;
                    switch (found[i]['arguments'][0].type) {
                        case 'Literal':
                            internClass = found[i]['arguments'][0].value;
                            break;
                        case 'CallExpression':
                            dynamic = true;
                            var searchObject = found[i]['arguments'][0].callee.object,
                                searchProperty = found[i]['arguments'][0].callee.property.name,
                                searchObjectName;
                            if (searchObject.type == 'ThisExpression') {
                                searchObjectName = 'this';
                            } else {
                                searchObjectName = searchObject.name;
                            }
                            internClass = searchObjectName + '.' + searchProperty;
                            break;
                        case 'MemberExpression':
                            dynamic = true;
                            var object = found[i]['arguments'][0].object,
                                prop = found[i]['arguments'][0].property;
                            if (object.type == 'ThisExpression') {
                                internClass = 'this.';
                            } else {
                                internClass = object.name + '.';
                            }
                            internClass += prop.name;
                            break;
                        default:
                            dynamic = true;
                            internClass = '***';
                            break;
                    }
                    foundClass.push({
                        name: internClass,
                        line: line,
                        col_start: col,
                        dynamic: dynamic
                    });
                    if (foundClass.length != 0) {
                        this.foundInits['creates'] = foundClass;
                    }
                }
            }
        }
    },
    /**
     * this Object is for going through another Object and find specific keywords in it
     */
    tokenRunner: {
        tokens: [],
        superToken: null,
        initJson: null,
        searchInJson: function (json, name, value) {
            this.initJson = json;
            this.tokens = [];
            this.runner(json, name, value, null);
            return this.tokens;
        },
        runner: function (json, name, value, parentJson) {
            for (var key in json) {
                if (json.hasOwnProperty(key)) {
                    if (key == name) {
                        if (value != null && json[name] == value) {
                            switch (value) {
                                case 'create':
                                case 'define':
                                    this.goUpstairs(this.initJson, parentJson);
                                    parentJson = this.superToken;
                                    break;
                                case 'Identifier':
                                case 'NewExpression':
                                    parentJson = json;
                                    break;
                            }
                            this.tokens.push(parentJson);
                        }
                    }
                    if (json[key] instanceof Object) {
                        this.runner(json[key], name, value, json);
                    }
                }
            }
        },
        goUpstairs: function (json, lookingForJson) {
            for (var key in json) {
                if(json.hasOwnProperty(key)) {
                    if (json[key] == lookingForJson) {
                        this.superToken = json;
                        break;
                    }
                    if (json[key] != lookingForJson && json[key] instanceof Object) {
                        this.goUpstairs(json[key], lookingForJson);
                    }
                }
            }
        }
    }
};

module.exports = {
    /**
     * goes through every file mentioned in the filesArray and starts the class seeker
     *
     * @param filesArray {Array}
     * @param fastRunFiles {Array} contains RegExp-Strings of files which don't need to get full parsed
     * @returns {Object} {contents: {}, classes: {}, alias: {}, xtype: {}, ptype: {}, ftype: {}}
     */
    goThroughFiles : function(filesArray, fastRunFiles) {
        var skipPaths = [];
        fastRunFiles.forEach(function(regExp){
            skipPaths.push(new RegExp(regExp));
        });
        filesArray.forEach(function (file) {
            var currentFile = fs.readFileSync(file, 'utf8'),
                error = false;
            try {
                var parser = esprima.parse(currentFile, {loc: true});
            } catch (e) {
                console.log('Error: ' + file);
                error = true;
            }
            if (!error) {
                classSeeker.lookUp(parser, file, currentFile, skipPaths);
            }
        });
        return classDependencies;
    }
};