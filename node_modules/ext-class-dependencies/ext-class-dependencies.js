/**
 * This class seeks for dependencies between classes and creates in the tmp folder files which could be executed with graphViz dot task
 * To use this class you need an array like the following:
 * {
 *  "contents":{
 *      "/the/absolute/path/to/this/class.js"  : {
 *          "code": "this is content of this file",
 *          "loc": {
 *              "total": 1,
 *              "source": 1
 *  "classes":{
 *      "AnyClassname": {
 *          "path": "/the/absolute/path/to/this/class.js",
 *          "declarations": {},
 *         "inits": {}
 *      }
 *  },
 *  "alias":{
 *      "aliasName": "realClassName"
 *  },
 *  "xtype":{
 *      "xTypeName": "realClassName"
 *  },
 *  "anyOtherType":{
 *      "otherTypeName": "realClassName"
 *  }, ...
 *}
 */

var fs = require('fs'),
    path = require('path');

var logic = {
    "specificDependencieArray" : {
        "startClasses": {},
        "extends": {},
        "extendsRevert": {},
        "mixins": {},
        "mixinsRevert": {}
    },
    "necessaryClasses" : [],
    "contents" : {
        "extend" : {
            "classes" : {},
            "dot": ''
        },
        "mixin"  : {
            "classes" : {},
            "dot": ''
        },
        "instances": {
            "classes": {},
            "options" : {},
            "dot": ''
        },
        "all": {
            "classes": {},
            "dot": ''
        },
        "analysis": {
            "dot": ''
        }
    },
    "constants" : {
        "up" : 'up',
        "down": 'down',
        "extNamespace": 'Ext.'
    },
    namespaceColors: {},
    /**
     * Goes through every entry in classArray and looks for matching classes and seeks which class depends on another one
     *
     * @param classArray {Object}
     * @param classContents {Object}
     * @param pathsToBeShown {Array} strings of RegEx's
     */
    makeDependencieArray : function (classArray, classContents, pathsToBeShown){
        var pathsRegEx = [];
        pathsToBeShown.forEach(function(path){
            pathsRegEx.push(new RegExp(path));
        });
        for(var className in classArray) {
            if (classArray.hasOwnProperty(className)) {
                if (this.lookForPath(classArray[className].path, pathsToBeShown)) {
                    this.specificDependencieArray.startClasses[className] = {};
                    if(classContents.hasOwnProperty(classArray[className].path)){
                        this.specificDependencieArray.startClasses[className] = {
                            "source": classContents[classArray[className].path].loc.source,
                            "comment": classContents[classArray[className].path].loc.comment,
                            "empty" : classContents[classArray[className].path].loc.empty,
                            "complexity": 0
                        };
                    }
                    this.specificDependencieArray.startClasses[className].functionCount = classArray[className].functions.length;
                }
                if (classArray[className].hasOwnProperty('declarations')) {
                    var declarations = classArray[className].declarations;
                    for (var declarationType in declarations) {
                        if (declarations.hasOwnProperty(declarationType)) {
                            switch (declarationType) {
                                case "extend":
                                    this.specificDependencieArray.extends[className] = declarations.extend.name;
                                    if(!this.specificDependencieArray.extendsRevert.hasOwnProperty(declarations.extend.name)){
                                        this.specificDependencieArray.extendsRevert[declarations.extend.name] = [];
                                    }
                                    this.specificDependencieArray.extendsRevert[declarations.extend.name].push(className);
                                    break;
                                case "mixins":
                                    if(!this.specificDependencieArray.mixins.hasOwnProperty(className)){
                                        this.specificDependencieArray.mixins[className] = [];
                                    }
                                    for(var i =0; i<declarations.mixins.length; i++){
                                        if(!this.specificDependencieArray.mixinsRevert.hasOwnProperty(declarations.mixins[i].name)) {
                                            this.specificDependencieArray.mixinsRevert[declarations.mixins[i].name] = [];
                                        }
                                        this.specificDependencieArray.mixins[className].push(declarations.mixins[i].name);
                                        this.specificDependencieArray.mixinsRevert[declarations.mixins[i].name].push(className);
                                    }
                                    break;
                            }
                        }
                    }
                }
            }
        }
    },
    /**
     * Makes an Array, containing every class which is needed to build the output
     *
     * @param classArray {Object}
     * @param pathsToBeShown {Array}
     * @param namespaceColors {Object} defines which namespace should be shown in which color
     */
    lookForNecessaryClasses : function (classArray, pathsToBeShown, namespaceColors){
        this.namespaceColors = namespaceColors;
        this.makeDependencieArray(classArray.classes, classArray.contents, pathsToBeShown);
        var startClassNames = Object.keys(this.specificDependencieArray.startClasses);
        for(var i = 0; i < startClassNames.length; i++){
            this.lookForUpperClasses(startClassNames[i]);
            this.lookForLowerClasses(startClassNames[i]);
        }
        this.necessaryClasses = startClassNames.concat(this.necessaryClasses);
        this.makeTextFile(classArray);
    },
    /**
     * Seeks the dependencies which come before one class
     *
     * @param className {String}
     */
    lookForUpperClasses : function (className){
        if (this.specificDependencieArray.extends.hasOwnProperty(className)) {
            if(this.necessaryClasses.indexOf(this.specificDependencieArray.extends[className]) === -1
                && !this.specificDependencieArray.startClasses.hasOwnProperty(this.specificDependencieArray.extends[className])) {
                this.necessaryClasses.push(this.specificDependencieArray.extends[className]);
                if(this.specificDependencieArray.extends[className].indexOf(this.constants.extNamespace) !== 0) {
                    this.lookForUpperClasses(this.specificDependencieArray.extends[className]);
                }
            }
        }
        this.seekInArray(className,this.specificDependencieArray.mixins, this.constants.up);
    },
    /**
     * Seeks the dependencies which come after one class
     *
     * @param className {String}
     * @param startClass {String} optional (just for recursive runs)
     */
    lookForLowerClasses : function (className, startClass){
        startClass = startClass || className;
        this.seekInArray(className, this.specificDependencieArray.extendsRevert, this.constants.down, startClass);
        this.seekInArray(className, startClass, this.specificDependencieArray.mixinsRevert, this.constants.down, startClass);
    },
    seekInArray: function (className, array, goForward, startClass){
        if(array.hasOwnProperty(className)){
            for(var k = 0; k<array[className].length;k++){
                if(this.necessaryClasses.indexOf(array[className][k]) === -1
                    && !this.specificDependencieArray.startClasses.hasOwnProperty(array[className][k])) {
                    this.necessaryClasses.push(array[className][k]);
                }
                if(array[className][k].indexOf(this.constants.extNamespace) !== 0) {
                    switch (goForward){
                        case this.constants.down:
                            this.specificDependencieArray.startClasses[startClass].complexity++;
                            this.lookForLowerClasses(array[className][k], startClass);
                            break;
                        case this.constants.up:
                            this.lookForUpperClasses(array[className][k]);
                            break;
                    }
                }
            }
        }
    },
    /**
     * Adds a class to a file with the right options depending on the namespace
     *
     * @param classArray {Array} for only this class
     * @param className {String}
     * @param type {String} where to add the class
     */
    addClassOption : function (classArray, className, type){
        if(!this.contents[type].classes.hasOwnProperty(className)){
            var namespace = className.split('.')[0];
            if(typeof  classArray !== 'undefined'){
                this.contents[type].classes[className] = {tooltip : classArray.path.replace(new RegExp(path.sep.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"),'g'),'/')};
            } else {
                this.contents[type].classes[className] = {};
            }
            if(this.namespaceColors.hasOwnProperty(namespace)){
                this.contents[type].classes[className].fillcolor = this.namespaceColors[namespace];
            } else {
                this.contents[type].classes[className].fillcolor = "cornflowerblue";
            }
            if(this.specificDependencieArray.startClasses.hasOwnProperty(className)){
                this.contents[type].classes[className].style = 'filled, bold';
            }
        }
    },
    /**
     * Detects if a path matches to the filter
     *
     * @param pathToClass {String}
     * @param pathToLook {Array} RegExp-filter
     * @returns {boolean}
     */
    lookForPath: function (pathToClass, pathToLook) {
        for(var k = 0; k < pathToLook.length; k++) {
            if (pathToClass.replace(new RegExp(path.sep.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"),'g'),'/').match(pathToLook[k])) {
                return true;
            }
        }
        return false;
    },
    createTable: function (){
        var startClasses = this.specificDependencieArray.startClasses,
            table = '',
            total = {
                "source":   0,
                "comment":  0,
                "empty":    0,
                "func":     0
            },
            startClassNames = Object.keys(startClasses).sort();
        startClassNames.forEach(function(className, index){
            var bgcolor = 'white',
                bordercolor = 'gainsboro';
            if(index % 2 === 0){
                bgcolor = 'gainsboro';
                bordercolor = 'white';
            }
            table += "<TR>" +
            '<TD ALIGN="LEFT" BGCOLOR="' + bgcolor + '" COLOR="'+bordercolor+'" BORDER="1"><B>' + className + '</B></TD>' +
            '<TD BGCOLOR="' + bgcolor + '" COLOR="'+bordercolor+'" BORDER="1">'+startClasses[className].source + '</TD>' +
            '<TD BGCOLOR="' + bgcolor + '" COLOR="'+bordercolor+'" BORDER="1">' + startClasses[className].comment + '</TD>' +
            '<TD BGCOLOR="' + bgcolor + '" COLOR="'+bordercolor+'" BORDER="1">' + startClasses[className].empty + '</TD>' +
            '<TD BGCOLOR="' + bgcolor + '" COLOR="'+bordercolor+'" BORDER="1">' + startClasses[className].functionCount + '</TD>' +
            '<TD BGCOLOR="' + bgcolor + '" COLOR="'+bordercolor+'" BORDER="1">' + startClasses[className].complexity + '</TD>' +
            '</TR>';
            total.source += startClasses[className].source;
            total.comment += startClasses[className].comment;
            total.empty += startClasses[className].empty;
            total.func += startClasses[className].functionCount;
        });
        table = '<TABLE BORDER="0" CELLBORDER="0" CELLSPACING="0" CELLPADDING="5">' +
        '<TR>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white"><B>Class</B></FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white"><B>Source LOC</B></FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white"><B>Comment LOC</B></FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white"><B>empty LOC</B></FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white"><B>functions</B></FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white"><B>Dependencies</B></FONT></TD>' +
        '</TR>' +
        table +
        "<TR>" +
        '<TD ALIGN="LEFT" BGCOLOR="dimgray"><FONT COLOR="white"><B>Total</B></FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white">'+total.source+'</FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white">'+total.comment+'</FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white">'+total.empty+'</FONT></TD>' +
        '<TD BGCOLOR="dimgray"><FONT COLOR="white">'+total.func+'</FONT></TD>' +
        '<TD BGCOLOR="dimgray"></TD>' +
        "</TR>" +
        "</TABLE>";
        return table;
    },
    /**
     * Goes through the necessary classes and writes the files for graphViz in the tmp-folder using dot-language
     *
     * @param classes {Array}
     */
    makeTextFile: function (classes){
        for(var a = 0; a < this.necessaryClasses.length; a++){
            var className = this.necessaryClasses[a],
                classArray = classes.classes[className];
            if(typeof classArray !== 'undefined'){
                if(classArray.hasOwnProperty('declarations')) {
                    for(var declaration in classArray.declarations) {
                        if(classArray.declarations.hasOwnProperty(declaration)) {
                            switch (declaration){
                                case "extend":
                                    var extendName = classArray.declarations.extend.name;
                                    if (this.necessaryClasses.indexOf(extendName) >= 0) {
                                        this.contents.extend.dot += '"' + extendName  + '"->"' +  className + '"[dir="back"];';
                                        this.contents.all.dot += '"' + extendName  + '"->"' +  className + '"[color="green" dir="back"];';
                                        this.addClassOption(classes.classes[extendName], extendName, 'extend');
                                        this.addClassOption(classes.classes[extendName], extendName, 'all');
                                        this.addClassOption(classes.classes[className], className, 'all');
                                        this.addClassOption(classes.classes[className], className, 'extend');
                                    }
                                    break;
                                case "mixins":
                                    var mixins = classArray.declarations.mixins,
                                        mixinDot = '{ ',
                                        addedMixinClasses = 0;
                                    for (var i = 0; i < mixins.length; i++) {
                                        var mixinName = mixins[i].name;
                                        if (this.necessaryClasses.indexOf(mixinName) >= 0) {
                                            addedMixinClasses++;
                                            mixinDot += '"' + mixinName + '" ';
                                            this.addClassOption(classes.classes[mixinName], mixinName, 'mixin');
                                            this.addClassOption(classes.classes[mixinName], mixinName, 'all');
                                        }

                                    }
                                    mixinDot += '}';
                                    if (addedMixinClasses > 0) {
                                        this.contents.mixin.dot += mixinDot + '-> "' + className + '"[dir="back"];';
                                        this.contents.all.dot += mixinDot + '-> "' + className + '"[color="red" dir="back"];';
                                        this.addClassOption(classes.classes[className], className, 'mixin');
                                        this.addClassOption(classes.classes[className], className, 'all');
                                    }
                                    break;
                                case "requires":
                                case "uses":
                                    if(this.specificDependencieArray.startClasses.hasOwnProperty(className)
                                        && classArray.declarations[declaration].length > 0) {
                                        var requireUseDot = '{ ';
                                        for (var m = 0; m < classArray.declarations[declaration].length; m++) {
                                            var requireUseName = classArray.declarations[declaration][m].name;
                                            requireUseDot += '"' + requireUseName + '" ';
                                            this.addClassOption(classes.classes[requireUseName], requireUseName, 'instances');
                                            this.addClassOption(classes.classes[requireUseName], requireUseName, 'all');
                                        }
                                        requireUseDot += '}';
                                        this.contents.instances.dot += requireUseDot+' -> "' + className + '"[label="'+declaration+'" dir="back"];';
                                        this.contents.all.dot += requireUseDot+' -> "' + className + '"[color="blue" fontcolor="blue" label="'+declaration+'" dir="back"];';
                                        this.addClassOption(classes.classes[className], className, 'instances');
                                        this.addClassOption(classes.classes[className], className, 'all');
                                    }
                                    break;
                            }
                        }
                    }
                }
                if (classArray.hasOwnProperty('inits') && this.specificDependencieArray.startClasses.hasOwnProperty(className)) {
                    if (Object.keys(classArray.inits).length > 0) {
                        var initials = '';
                        for (var init in classArray.inits) {
                            if (classArray.inits.hasOwnProperty(init)) {
                                switch (init) {
                                    case "ObjectInit":
                                    case "creates":
                                        for (var k = 0; k < classArray.inits[init].length; k++) {
                                            if (!classArray.inits[init][k].dynamic) {
                                                initials += '"' + classArray.inits[init][k].name + '" ';
                                                this.addClassOption(classes.classes[classArray.inits[init][k].name], classArray.inits[init][k].name, 'instances');
                                                this.addClassOption(classes.classes[classArray.inits[init][k].name], classArray.inits[init][k].name, 'all');
                                            }
                                        }
                                        break;
                                    case "xtype":
                                    case "ftype":
                                    case "ptype":
                                        for (var l = 0; l < classArray.inits[init].length; l++) {
                                            if (!classArray.inits[init][l].dynamic) {
                                                var initClassNameType = classArray.inits[init][l].name;
                                                if (classes[init].hasOwnProperty(initClassNameType)) {
                                                    var initClassNameRaw = classes[init][initClassNameType];
                                                    initials += '"' + initClassNameRaw + '" ';
                                                    this.addClassOption(classes.classes[initClassNameRaw], initClassNameRaw, 'instances');
                                                    this.addClassOption(classes.classes[initClassNameRaw], initClassNameRaw, 'all');
                                                }
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                        if (initials !== '') {
                            this.contents.instances.dot += '{ ' + initials + '} -> "' + className + '"[label="instantiate" dir="back"];';
                            this.contents.all.dot += '{ ' + initials + '} -> "' + className + '"[color="blue" fontcolor="blue" label="instantiate" dir="back"];';
                            this.addClassOption(classes.classes[className], className, 'instances');
                            this.addClassOption(classes.classes[className], className, 'all');
                        }
                    }
                }
            }
        }

        if (!fs.existsSync('./tmp')) {
            fs.mkdirSync('./tmp');
        }
        //this makes the legend in the file which contains all types of dependencies
        this.contents.all.dot = ' subgraph cluster_classes{ label=" "; color="invis"; "LegendTargetHelper"[style="invis"]; '+this.contents.all.dot+'}' +
        ' subgraph cluster_legend{' +
        'label=<<B>Legend</B>>;' +
        'extendClass2[label="Class 2"]; extendClass1[label="Class 1"]; extendClass2->extendClass1[color="green" fontcolor="green" dir="back" label="Class 1 extends Class 2"]; ' +
        'mixinClass2[label="Class 2"]; mixinClass1[label="Class 1"]; mixinClass2->mixinClass1[color="red" fontcolor="red" dir="back" label="Class 1 has mixin of Class 2"]; ' +
        'instancesClass2[label="Class 2"]; instancesClass1[label="Class 1"]; instancesClass2->instancesClass1[color="blue" fontcolor="blue" label="Class 1 instantiates / uses / requires Class 2" dir="back"];' +
        'filterClass[label="Class with bold border" style="bold"]; filterInfo[shape=plaintext, style=solid, label="This is a filtered class", width=3.5]; filterClass->filterInfo[style="invis"]} ' +
        '"LegendTargetHelper"->"extendClass1"[style="invis"] ';
        var contents = this.contents;
        this.contents.analysis.dot = 'c [shape=none width=0 height=0 margin=0 label=<' + this.createTable() + '>]';
        Object.keys(this.contents).forEach(function(contentType){
            if(contents.hasOwnProperty(contentType)) {
                var options = '';
                if(contents[contentType].hasOwnProperty('classes')) {
                    for (var optionClassName in contents[contentType].classes) {
                        if (contents[contentType].classes.hasOwnProperty(optionClassName)) {
                            options += '"' + optionClassName + '" [';
                            for (var optionName in contents[contentType].classes[optionClassName]) {
                                if (contents[contentType].classes[optionClassName].hasOwnProperty(optionName)) {
                                    options += optionName + '="' + contents[contentType].classes[optionClassName][optionName] + '" ';
                                }
                            }
                            options += ']; '
                        }
                    }
                }
                options = 'node [style=filled; fontname="Helvetica";]; rankdir=LR; splines="polyline"; fontname="Helvetica"; labelloc="t"; label=<<FONT POINT-SIZE="35"><B>'+ contentType +'</B></FONT>>;' + options;
                contents[contentType].dot = 'digraph '+ contentType +'{'+ options + contents[contentType].dot + '}';
                fs.writeFile('./tmp/' + contentType + '.txt', contents[contentType].dot, function (err) {
                    if (err) {
                        return console.log(err);
                    }
                    console.log("The file " + contentType + ".txt has been saved!");
                });
            }
        });
    }
};

module.exports = {
    /**
     * Start the process to create the dependencies for the classes you give
     * @param classes {Object} all classes which need to be included
     * @param pathsToBeShown {Array} the paths which you like to display
     * @param namespaceColors {Object} defines which namespace should be shown in which color
     */
    makeTextFile : function(classes, pathsToBeShown, namespaceColors){
        logic.lookForNecessaryClasses(classes, pathsToBeShown, namespaceColors);
    }
};